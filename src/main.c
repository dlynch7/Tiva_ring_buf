//*****************************************************************************
//
// main.c - Example of a real-time control loop and ring buffer for passing
//  data from the control loop to a client PC over UART.
//
//*****************************************************************************

// Standard C includes:
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// TivaWare includes:
#include "inc/hw_ints.h" // need this for timer-generated interrupt
#include "inc/hw_memmap.h"
#include "inc/hw_timer.h" // need this for timer-generated interrupt
#include "inc/hw_types.h"
#include "inc/hw_uart.h"
#include "driverlib/debug.h"
#include "driverlib/fpu.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h" // guess what we need this for!
#include "driverlib/pin_map.h"
#include "driverlib/rom.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "driverlib/timer.h" // need this for timer-generated interrupt
#include "driverlib/uart.h"
#include "utils/uartstdio.h"

// Custom includes:
#include "setup.h"
#include "ring_buffer.h"

//*****************************************************************************
//
//! An example application of a ring buffer for real-time data collection.
//!
//! Data (nonsense) is written to a ring buffer at a fixed frequency.
//! The while(1) "superloop" in main() then reads from the ring buffer and
//! echoes it over UART0 where a client PC program can record the data for
//! post-processing, analysis, etc.
//!
//! The ring buffer is implemented in ring_buffer.{c,h} (shocking, I know!)
//! This implementation uses a queue where each element is a custom struct.
//! This way, the user can modify the ring buffer to hold whatever data types
//! are of interest.
//
//*****************************************************************************

//*****************************************************************************
//
// Macros
//
//*****************************************************************************
#define ISR_FREQ 25 // frequency (in Hz) of timer A0 interrupt
#define MENU_BUF_LEN 100 // length of junk buffer for receiving stuff from PC

//*****************************************************************************
//
// Global variables
//
// (all global variables are identified by the "_g" suffix)
//
//*****************************************************************************
uint8_t buffer_write_permission_g;  // permits MyISR() to write to ring buffer
uint8_t buffer_read_permission_g;   // permits main() to read from ring buffer

//*****************************************************************************
//
// This function sets up Timer A0 to generate interrupts at a frequency
// specified by the macro ISR_FREQ (#define'd above)
//
//*****************************************************************************
void TimerBegin(void)
{
    SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0); // Enable the peripherals used by this example.
    IntMasterEnable(); // Enable processor interrupts.
    TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC); // Configure a 32-bit periodic timer.
    TimerLoadSet(TIMER0_BASE, TIMER_A, SysCtlClockGet() / ISR_FREQ);
    IntEnable(INT_TIMER0A); // Setup the interrupts for the timer timeouts.
    IntPrioritySet(INT_TIMER0A, 0x00); // set the Timer 0A interrupt priority to be "HIGH"
    TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT);
    TimerEnable(TIMER0_BASE, TIMER_A); // Enable the timer.
    UARTprintf("Timer A0 initialized at %d Hz!\n",ISR_FREQ);
}

//*****************************************************************************
//
// The interrupt handler for the periodic interrupt generated by Timer A0
//
//*****************************************************************************
void MyISR(void) // normally I'd hate to name anything "My..."
{
    // declare static local variables:
    static uint8_t tic = 0, dec_count = 0;
    static uint16_t thing1 = 0;
    static uint16_t thing2 = 0;
    static int16_t  thing3 = 0;
    static int16_t  thing4 = 0;
    static int16_t  thing5 = 0;
    static uint8_t  thing6 = 0;

    // clear the timer interrupt:
    TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT); // always do this ASAP

    // Here you would do timing-critical tasks
    // (e.g., read from sensors, compute control efforts, send commands to amps)
    // Instead, we will just increment everything:
    thing1++;
    thing2++;
    thing3++;
    thing4++;
    thing5++;
    thing6++;

    // If the "write" permission flag has been set (happens in main()),
    // get ready to write everything to the ring buffer:
    if (buffer_write_permission_g==1)
    {
        GPIOPinWrite(GPIO_PORTF_BASE, LED_BLUE, LED_BLUE); // BLUE LED ON
        // if the DECIMATION counter is up, go ahead and write to the buffer:
        if (dec_count==DECIMATION) // DECIMATION is defined in circ_buffer.h
        {
            buffer_write(   thing1,\
                            thing2,\
                            thing3,\
                            thing4,\
                            thing5,\
                            thing6,\
                            get_read_index(),\
                            get_write_index());
            dec_count = 0;
        }
        ++dec_count;

    }

    // toggle the devboard's red LED:
    if (tic == 0)
    {
        GPIOPinWrite(GPIO_PORTF_BASE, LED_RED, LED_RED); // LED on
        tic = 1;
    }
    else
    {
        GPIOPinWrite(GPIO_PORTF_BASE, LED_RED, 0); // LED OFF
        tic = 0;
    }


}


//*****************************************************************************
//
// The error routine that is called if the driver library encounters an error.
//
//*****************************************************************************
#ifdef DEBUG
void
__error__(char *pcFilename, uint32_t ui32Line)
{
}
#endif

//*****************************************************************************
//
// Configure the UART and its pins.  This must be called before UARTprintf().
//
//*****************************************************************************
void
ConfigureUART(void)
{
    //
    // Enable the GPIO Peripheral used by the UART.
    //
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);

    //
    // Enable UART0
    //
    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);

    //
    // Configure GPIO Pins for UART mode.
    //
    GPIOPinConfigure(GPIO_PA0_U0RX);
    GPIOPinConfigure(GPIO_PA1_U0TX);
    GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);

    //
    // Use the internal 16MHz oscillator as the UART clock source.
    //
    UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);

    //
    // Initialize the UART for console I/O.
    //
    UARTStdioConfig(0, 115200, 16000000);
}

//*****************************************************************************
//
// Print "Hello World!" to the UART on the evaluation board.
//
//*****************************************************************************
int
main(void)
{

    //*************************************************************************
    // Local variable declarations
    //*************************************************************************
    uint16_t i = 0; // just a simple counter, used in the superloop (below)
    buf_out_t buf_slice; // custom struct, takes output from buffer_read()
    buf_out_t *buf_slice_ptr = &buf_slice; // store address of buf_slice
    char menu_buf[MENU_BUF_LEN]; // buffer for receiving short commands from PC

    //*************************************************************************
    // Startup
    //*************************************************************************

    // Enable lazy stacking for interrupt handlers.  This allows floating-point
    // instructions to be used within interrupt handlers, but at the expense of
    // extra stack usage.
    FPULazyStackingEnable();

    // Set the clocking to run directly from the crystal.
    SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ |
                       SYSCTL_OSC_MAIN);

    // Initialize the UART.
    ConfigureUART();

    // Hello!
    UARTprintf("Hello, world!\n");

    // Initialize onboard RBG LEDs:
    LED_Init();

    // Initialize the ring buffer:
    buffer_write_permission_g = 0;
    buffer_read_permission_g = 0;
    buffer_reset();
    UARTprintf("Ring buffer initialized.\n");

    // Initialize the timer-based ISR (our stand-in for a control loop):
    TimerBegin();
    UARTprintf("Control loop initialized.\n");

    // do some unnecessary floating-point math to see if the Makefile works:
    float foo;
    foo = ((float) (rand() % 1000000));
    sprintf(menu_buf,"foo = %.2f.\n",foo);
    UARTprintf("%s",menu_buf);
    //foo = 3.0/2.0;
    //UARTprintf("(int) foo = %d.\n",(int)foo);

    // If we got this far, setup is complete!
    UARTprintf("Setup complete!\n");

    // We are finished.  Hang around doing nothing.
    while(1)
    {
        UARTgets(menu_buf,MENU_BUF_LEN); // non-blocking!
        buffer_reset();
        switch (menu_buf[0])
        {
            case 'e': // erase buffer
            {
                buffer_erase();
                UARTprintf("Ring buffer erased.\n");
                break;
            }
            case 'h': // view read and write heads
            {
                UARTprintf("read index: %d.\n",get_read_index());
                UARTprintf("write index: %d.\n",get_write_index());
                break;
            }
            case 'q': // quit (just returns to beginning of superloop)
                break;
            case 'r': // send ring buffer contents to client via batch transmission
            {
                buffer_reset();
                // permit MyISR() to write to ring buffer:
                buffer_write_permission_g = 1;
                GPIOPinWrite(GPIO_PORTF_BASE, LED_BLUE, 0); // BLUE LED OFF
                GPIOPinWrite(GPIO_PORTF_BASE, LED_GREEN, LED_GREEN); // GREEN LED ON
                for (i=0; i<NSAMPLES; i++) // NSAMPLES is #defined in ring_buffer.h
                {
                    buffer_read(buf_slice_ptr);
                    UARTprintf("%d,%d,%d,%d,%d,%d,%d,%d,%d\n",\
                        i,\
                        buf_slice.thing1,\
                        buf_slice.thing2,\
                        buf_slice.thing3,\
                        buf_slice.thing4,\
                        buf_slice.thing5,\
                        buf_slice.thing6,\
                        buf_slice.readhead,\
                        buf_slice.writehead);
                }
                buffer_write_permission_g = 0; // disable write permission when done (safeguard)
                buffer_read_permission_g = 0;  // disable read permission when done
                UARTprintf("Done reading from ring buffer.\n");
                GPIOPinWrite(GPIO_PORTF_BASE, LED_BLUE, 0); // BLUE LED OFF
                GPIOPinWrite(GPIO_PORTF_BASE, LED_GREEN, 0); // GREEN LED OFF
                break;
            } // end 'r' case
            default:
            {
                UARTprintf("error: %c is unknown menu option\n",menu_buf[0]);
                break;
            }

        }
    }
    return 0; // something, somewhere, went horribly wrong.
}
